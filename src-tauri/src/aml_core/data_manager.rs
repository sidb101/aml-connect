//when datamanager calls db manager (to store audio metadata in database)
//this crate would then be needed
//use crate::aml_core::network_manager::*;

use anyhow::{ensure, Context, Result};
use directories::ProjectDirs;
use std::fs;
use std::io::{self, Read, Write};
use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};
use ts_rs::TS;

#[derive(Debug, Clone, Serialize, Deserialize)]
enum DataSet {
    Testing,
    Validation,
    Training,
}

#[derive(Debug, Serialize, Deserialize, TS)]
#[ts(export)]
pub enum Error {
    FileNotFound,
    ProcessingError,
    FileTooLarge,
    UnsupportedFileExtension,
    // Add more error variants as needed.
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FileUploadRequest {
    file_name: String, // relativePath to file from baseDir (e.g. \project1\training\glass-break.wav)
    dataset_type: DataSet,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FilesUploadRequest {
    proj_slug: String,
    input_files: Vec<FileUploadRequest>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FileUploadErrorResponse {
    file_name: String,
    error_response: Error,
}

//this struct will also be used got QueryAudioFiles
#[derive(Debug, Serialize, Deserialize)]
pub struct FileMetadata {
    file_id: String,   // generated by db
    file_name: String, // relativePath to file from baseDir (e.g. \project1\training\glass-break.wav)
    dataset_type: DataSet,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FilesUploadResponse {
    upload_success_files: Vec<FileMetadata>, //array of relative file paths of input files that were successfully stored in server side folder
    upload_failed_files: Vec<FileUploadErrorResponse>,
    attempted: i32,
    succeeded: i32,
    failed: i32,
}

pub type SaveFilesResponse = Result<FilesUploadResponse, Error>;

fn get_relative_path(base_dir: &Path, absolute_path: &Path) -> Option<PathBuf> {
    // Ensure that both paths are absolute
    if !base_dir.is_absolute() || !absolute_path.is_absolute() {
        return None;
    }

    // Calculate the relative path
    let relative_path = absolute_path.strip_prefix(base_dir).ok()?;
    Some(relative_path.to_path_buf())
}

//retrieves file from source, and store in destination folder
//returns the absolute file path of the resulting file
fn copy_file(source_path: &Path, destination_folder: &Path) -> io::Result<PathBuf> {
    let file_name = source_path
        .file_name()
        .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "Invalid source file path"))?
        .to_owned();

    let mut source_file = fs::File::open(source_path)?;
    let mut contents = Vec::new();
    source_file.read_to_end(&mut contents)?;

    let destination_path = destination_folder.join(&file_name);
    fs::create_dir_all(destination_folder)?;

    let mut destination_file = fs::File::create(&destination_path)?;
    destination_file.write_all(&contents)?;

    Ok(destination_path)
}

pub fn store_in_app_data(file_path: &str, base_dir: &str) -> Result<String> {
    let proj_dirs = ProjectDirs::from("com", "aspinity", "aml_connect")
        .with_context(|| "Failed to get application directory\n")?;

    let dest_folder = proj_dirs.data_local_dir();
    let file_path = Path::new(file_path);
    let base_dir = Path::new(base_dir);

    //let dest_folder = format!("{}\\",proj_dirs.data_local_dir().display());
    let abs_dest_file_path = copy_file(file_path, &dest_folder)
        .with_context(|| "Failed to copy file to destination\n")?;

    let rel_dest_file_path = get_relative_path(base_dir, abs_dest_file_path.as_ref())
        .with_context(|| "relative path calculation failed.")?;

    let rel_dest_file_path = rel_dest_file_path
        .to_str()
        .with_context(|| "Failed to convert application directory to string\n")?
        .to_owned();
    Ok(rel_dest_file_path)
}

fn validate_extension(f: &FileUploadRequest, extension: String) -> Result<()> {
    let rel_path = Path::new(&f.file_name);
    ensure!(
        rel_path
            .extension()
            .unwrap()
            .to_os_string()
            .to_str()
            .unwrap()
            == extension,
        "Invalid file extension"
    );
    Ok(())
}

fn validate_exists(f: &FileUploadRequest) -> Result<()> {
    // validate file exists at the given relative path
    let rel_path = Path::new(&f.file_name);
    ensure!(rel_path.exists(), "File does not exist");
    Ok(())
}

fn validate_size(f: &FileUploadRequest) -> Result<()> {
    // validate file size is less than 20 MB
    let rel_path = Path::new(&f.file_name);
    ensure!(
        rel_path.metadata().unwrap().len() < 20 * 1024 * 1024,
        "File size is too large"
    );
    Ok(())
}

pub fn validate_files(files: &Vec<FileUploadRequest>) -> FilesUploadResponse {
    let mut response: FilesUploadResponse = FilesUploadResponse {
        upload_success_files: Vec::new(),
        upload_failed_files: Vec::new(),
        attempted: files.len() as i32,
        succeeded: 0,
        failed: 0,
    };

    for f in files {
        if validate_exists(f).is_err() {
            response.failed += 1;
            response.upload_failed_files.push(FileUploadErrorResponse {
                file_name: f.file_name.clone(),
                error_response: Error::FileNotFound,
            });
        }
        else if validate_extension(f, "wav".to_string()).is_err() {
            response.failed += 1;
            response.upload_failed_files.push(FileUploadErrorResponse {
                file_name: f.file_name.clone(),
                error_response: Error::UnsupportedFileExtension,
            });
        }
        else if validate_size(f).is_err() {
            response.failed += 1;
            response.upload_failed_files.push(FileUploadErrorResponse {
                file_name: f.file_name.clone(),
                error_response: Error::FileTooLarge,
            });
        }
        else {
            // generate file_id by calling db here and add to response
            response.succeeded += 1;
            response.upload_success_files.push(FileMetadata {
                file_id: String::from("1234"),
                file_name: f.file_name.clone(),
                dataset_type: f.dataset_type.clone(),
            });
        }
    }

    response
}

/// Validates the input files stored in the appdata dir and saves their metadata to the database
///
/// # Arguments
/// * `FilesUploadRequest`: JSON struct holding project_slug and vector of FileUploadRequest
/// 
/// # Returns
/// * `SaveFilesResponse`: A result type, holding Ok(FilesUploadResponse) and Err(Error) variants
pub fn save_input_files(input: &FilesUploadRequest) -> SaveFilesResponse {
    // validation of the list of input file paths (file will be deleted if invalid)
    let ans: FilesUploadResponse = validate_files(&input.input_files);

    //TODO: save metadata to db

    //TODO: return list of IDs for successful uploads
    Ok(ans)
    // Err(Error::FileNotFound)
}
