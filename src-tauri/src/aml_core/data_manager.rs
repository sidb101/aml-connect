//when datamanager calls db manager (to store audio metadata in database)
//this crate would then be needed
//use crate::aml_core::network_manager::*;

use anyhow::{ensure, Context, Result};
use directories::ProjectDirs;
use std::fs;
use std::io::{self, Read, Write};
use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};
use ts_rs::TS;

#[derive(Debug, Clone, Serialize, Deserialize)]
enum DataSet {
    Testing,
    Validation,
    Training,
}

#[derive(Debug, Serialize, Deserialize, TS)]
#[ts(export)]
pub enum Error {
    FileNotFound,
    ProcessingError,
    FileTooLarge,
    UnsupportedFileExtension,
    // Add more error variants as needed.
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FileUploadRequest {
    file_name: String, // relativePath to file from baseDir (e.g. \project1\training\glass-break.wav)
    dataset_type: DataSet,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FilesUploadRequest {
    proj_slug: String,
    input_files: Vec<FileUploadRequest>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FileUploadErrorResponse {
    file_name: String,
    error_response: Error,
}

//this struct will also be used got QueryAudioFiles
#[derive(Debug, Serialize, Deserialize)]
pub struct FileMetadata {
    file_id: String,   // generated by db
    file_name: String, // relativePath to file from baseDir (e.g. \project1\training\glass-break.wav)
    dataset_type: DataSet,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FilesUploadResponse {
    upload_success_files: Vec<FileMetadata>, //array of relative file paths of input files that were successfully stored in server side folder
    upload_failed_files: Vec<FileUploadErrorResponse>,
    attempted: i32,
    succeeded: i32,
    failed: i32,
}

pub type SaveFilesResponse = Result<FilesUploadResponse, Error>;

pub fn create_project_dir_if_not_exists() -> Result<()>{
    let proj_dirs = ProjectDirs::from("com", "aspinity", "aml_connect")
        .with_context(|| "Failed to get application directory\n")?;
    let app_dir = proj_dirs.data_local_dir();
    if !app_dir.exists() {
        fs::create_dir_all(app_dir)
            .with_context(|| "Failed to create application directory\n")?;
    }
    Ok(())
}

pub fn get_project_dir() -> Result<PathBuf> {
    let proj_dirs = ProjectDirs::from("com", "aspinity", "aml_connect")
        .with_context(|| "Failed to get application directory\n")?;
    let app_dir = proj_dirs.data_local_dir();
    Ok(app_dir.to_path_buf())
}

fn validate_extension(f: &FileUploadRequest, extension: String) -> Result<()> {
    let rel_path = Path::new(&f.file_name);
    ensure!(
        rel_path
            .extension()
            .unwrap()
            .to_os_string()
            .to_str()
            .unwrap()
            == extension,
        "Invalid file extension"
    );
    Ok(())
}

fn validate_exists(f: &FileUploadRequest) -> Result<()> {
    // validate file exists at the given relative path
    let rel_path = Path::new(&f.file_name);
    ensure!(rel_path.exists(), "File does not exist");
    Ok(())
}

fn validate_size(f: &FileUploadRequest) -> Result<()> {
    // validate file size is less than 20 MB
    let rel_path = Path::new(&f.file_name);
    ensure!(
        rel_path.metadata().unwrap().len() < 20 * 1024 * 1024,
        "File size is too large"
    );
    Ok(())
}

pub fn validate_files(files: &Vec<FileUploadRequest>) -> FilesUploadResponse {
    let mut response: FilesUploadResponse = FilesUploadResponse {
        upload_success_files: Vec::new(),
        upload_failed_files: Vec::new(),
        attempted: files.len() as i32,
        succeeded: 0,
        failed: 0,
    };

    for file in files {
        if validate_exists(file).is_err() {
            response.failed += 1;
            response.upload_failed_files.push(FileUploadErrorResponse {
                file_name: file.file_name.clone(),
                error_response: Error::FileNotFound,
            });
        }
        else if validate_extension(file, "wav".to_string()).is_err() {
            response.failed += 1;
            response.upload_failed_files.push(FileUploadErrorResponse {
                file_name: file.file_name.clone(),
                error_response: Error::UnsupportedFileExtension,
            });
        }
        else if validate_size(file).is_err() {
            response.failed += 1;
            response.upload_failed_files.push(FileUploadErrorResponse {
                file_name: file.file_name.clone(),
                error_response: Error::FileTooLarge,
            });
        }
        else {
            // generate file_id by calling db here and add to response
            response.succeeded += 1;
            response.upload_success_files.push(FileMetadata {
                file_id: String::from("1234"),
                file_name: file.file_name.clone(),
                dataset_type: file.dataset_type.clone(),
            });
        }
    }

    response
}

/// Validates the input files stored in the appdata dir and saves their metadata to the database
///
/// # Arguments
/// * `FilesUploadRequest`: JSON struct holding project_slug and vector of FileUploadRequest
/// 
/// # Returns
/// * `SaveFilesResponse`: A result type, holding Ok(FilesUploadResponse) and Err(Error) variants
pub fn save_input_files(input: &FilesUploadRequest) -> SaveFilesResponse {
    // validation of the list of input file paths (file will be deleted if invalid)
    let ans: FilesUploadResponse = validate_files(&input.input_files);

    //TODO: save metadata to db
    

    //TODO: return list of IDs for successful uploads
    Ok(ans)
    // Err(Error::FileNotFound)
}
